#!/bin/sh

set -e

export HOME=/var/lib/unison
export UNISON=$HOME

check_pref () {
    if ! [ "$1" -a -r "$UNISON/$1.prf" ]
    then
        echo "Usage: $0 profilename [options]"
        echo "Profile $1 does not exist"
        exit 1
    else
        mkdir -p /run/unison
        LOCK="/run/unison/$1.lock"
    fi
}

# use pseudo-servercmd as information via SSH_ORIGINAL_COMMAND
# to be able to pass profile name to remote unison. This *needs*
# the proper command option in the authorized_key.
if [ "$SSH_ORIGINAL_COMMAND" ] # ssh invocation by unison master
then
    # may be run multiple times from the other side (systemd + from shell)
    eval "set -- $SSH_ORIGINAL_COMMAND"
    if [ "$1" == "unison-rsync" ]
    then
        exec "$@"
    else
        check_pref "$(echo "$1" | base64 -d)"
        shift
        exec /bin/flock --shared --conflict-exit-code 42 --wait 2 --no-fork "$LOCK" /bin/unison "$@"
    fi
elif [ "$INVOCATION_ID" ] # local systemd invocation
then
    # Do not allow any other invocation in daemon mode (ssh or systemd)
    check_pref "$1"
    exec /bin/flock --exclusive --conflict-exit-code 42 --wait 2 --no-fork "$LOCK" /bin/unison "$@" -servercmd "$(echo $1 | base64 -w0)"
else
    # do not use locking on this side, as we want to run unison even when the daemon is running locally.
    # Instead rely on a potential remote exclusive lock which will make this run fail if a remote
    # systemd service is running.
    check_pref "$1"
    exec /bin/unison "$@" -servercmd "$(echo $1 | base64 -w0)"
fi
